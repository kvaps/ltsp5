#!/bin/sh
#
#  Copyright (c) 2005 Canonical LTD
#
#  Author: Matt Zimmerman <mdz@canonical.com>
#
#  2006, Oliver Grawert <ogra@canonical.com>
#        Vagrant Cascadian <vagrant@freegeek.org>
#  2007, Scott Balneaves <sbalneav@ltsp.org>
#        Oliver Grawert <ogra@canonical.com>
#  2008, Vagrant Cascadian <vagrant@freegeek.org>
#        Warren Togami <wtogami@redhat.com>
#        Oliver Grawert <ogra@canonical.com>
#  2009, Warren Togami <wtogami@redhat.com>
#  2012, Alkis Georgopoulos <alkisg@gmail.com>
#  2018, Andrey Kvaps <kvapss@gmail.com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, you can find it on the World Wide
#  Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
#  Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#

usage() {
    cat <<EOF
Usage: $0 [OPTION] [CHROOT...]

Copies the boot/ directory from LTSP chroots to the TFTP directories
in order to make them available to PXE clients. Copying kernels from
inside NBD images is also supported. CHROOT can be a fullpath or a
subdirectory of the base directory, and if it's unset, all available
chroots are processed.

Options:
  -b, --base[=PATH]     The LTSP base directory. Defaults to /opt/ltsp if unspecified.
  -h, --help            Displays the ltsp-update-kernels help message.
      --version         Output version information and exit.
EOF
}

# List kernel versions in a descending order, while also respecting the e.g.
#   LIST_KERNELS="generic generic-pae *"
# order that the user may have put in $CHROOT/etc/ltsp/update-kernels.conf.
# Distros are required to set e.g. KERNEL_PREFIX="vmlinuz-*', KERNEL_SUFFIX="".
# The * goes where the version is expected to go.
kernel_split() {
    local orig_flags kernels arch loop_kernels kernel
    # Save values of flags, and restore them later.
    orig_flags=$(set +o)

    # Disable glob expansion for this function
    set -f
    for kernel in $(find "$BASE/$name/boot/" -type f -name "$KERNEL_PREFIX$KERNEL_SUFFIX" -printf "%f\n"); do
        # Validate the "arch"
        if [ "${LIST_KERNELS}" = "ALL" ]; then
            LIST_KERNELS="*"
        fi
        for arch in ${LIST_KERNELS:-*}; do
            case "$kernel" in
                $KERNEL_PREFIX$arch$KERNEL_SUFFIX)
                    echo "$kernel"
                    break 1
                    ;;
            esac
        done
    done | sed -n "$KERNEL_NAMES" | sort -k 4,4V -k 3,3rV

    eval "$orig_flags"
}

kernel_versions(){
    for arch in ${LIST_KERNELS:-"ALL"} ; do
        LIST_KERNELS="$arch" kernel_split | awk '{print $3$4}'
    done
}

kernel_variants(){
    kernel_split | awk '{print $4}' | sort -u
}

trap_cleanup() {
    # Stop trapping
    trap - 0 HUP INT QUIT KILL SEGV PIPE TERM
    umount_marked
    rmdir "$mnt"
}

update_kernels() {
    local name tftpdir tftpboot chroot 
    name=$1
    tftpdir=$2

    tftpboot="$tftpdir/$TFTP_BOOT_DIR"
    tftpboot=${tftpboot%/}

    # Loop-mounting NBD images in order to copy their kernels is supported
    # in order to allow for btrfs or ext loopback images, or images transferred
    # from other sources to the LTSP server.
    # But if both the chroot and the NBD image exist, the chroot is preferred,
    # to make updating BOOTPROMPT_OPTS in update-kernels.conf easier.
    # A PREFER_NBD_IMAGE environment variable is supported though, to make it
    # possible for `ltsp-update-image --revert` to use the NBD kernels.
    unset chroot
    if [ -x "$BASE/$name/bin/true" ] && [ "$PREFER_NBD_IMAGE" != true ]; then
        chroot="$BASE/$name"
    elif [ -f "$BASE/images/$name.img" ]; then
        if [ -z "$mnt" ]; then
            mnt=$(mktemp -d)
            trap "trap_cleanup" 0 HUP INT QUIT KILL SEGV PIPE TERM
        else
            umount_marked
        fi
        if mark_mount -o loop,ro "$BASE/images/$name.img" "$mnt"; then
            chroot="$mnt"
        fi
    fi
    if [ -z "$chroot" ]; then
        echo "Skipping invalid chroot: $name"
        continue
    fi
    echo "Updating $tftpdir directories for chroot: $name"

    # Source distro-specific variables from the chroot
    unset KERNEL_NAMES INITRD_NAME
    if [ -f "$chroot/etc/ltsp/update-kernels.conf" ]; then
        . "$chroot/etc/ltsp/update-kernels.conf"
    fi
    mkdir -p "$tftpboot/$name"
    cp -a "$chroot/boot/." "$tftpboot/$name/"

    # Generate pxelinux.cfg/default symlink if not present.
    if [ -f "$tftpboot/$name/pxelinux.cfg/ltsp" ]; then
        # Remove autogenerated pxelinux.cfg/default
        if [ -f "$tftpboot/$name/pxelinux.cfg/default" ]; then
            if [ ! -L "$tftpboot/$name/pxelinux.cfg/default" ]; then
                if grep -q '# This file is regenerated when update-kernels runs.' "$tftpboot/$name/pxelinux.cfg/default" ; then
                    rm -f "$tftpboot/$name/pxelinux.cfg/default"
                fi
            fi
        fi
        if [ ! -f "$tftpboot/$name/pxelinux.cfg/default" ]; then
            ln -sf ltsp "$tftpboot/$name/pxelinux.cfg/default" 
        fi
    fi

    # Ensure that the files are readable (LP: #759115) (Dracut initramfs)
    find "$tftpboot/$name/" -maxdepth 1 ! -perm -o=r -exec chmod a+r {} \;

    # OFW on Mac is lame, they cannot tftp from directories
    if [ -e "$tftpboot/$name/yaboot" ]; then
        if [ ! -e "$tftpdir/yaboot" ]; then
            ln -sf "$TFTP_BOOT_DIR/$name/yaboot" "$tftpdir/yaboot"
        fi
        if [ ! -e "$tftpdir/yaboot.conf" ]; then
            ln -sf "$TFTP_BOOT_DIR/$name/yaboot.conf" "$tftpdir/yaboot.conf"
        fi
    fi

    # Cleanup old kernels and images from tftpboot directory
    cleanup_kernels "$name" "$tftpboot" "$chroot"

    link_kernel_flavors "$tftpboot/$name"

    # Configure grub
    if [ -d /usr/lib/grub ]; then
        [ -d /usr/lib/grub/i386-pc ] || echo "Skipping Grub pc bootloader installation. Install the grub-pc-bin package if you need it."
        [ -d /usr/lib/grub/i386-efi ] || echo "Skipping Grub i386-efi bootloader installation. Install the grub-efi-ia32-bin package if you need it."
        [ -d /usr/lib/grub/x86_64-efi ] || echo "Skipping Grub x86_64-efi bootloader installation. Install the grub-efi-amd64-bin package if you need it."
        grub-mknetdir --net-directory="$tftpdir" --subdir="$TFTP_BOOT_DIR/$name/grub" &&
        generate_grub_config "$tftpboot/$name"
    else
        echo "Skipping Grub configuration. Install the grub-common package if you need it."
    fi
}

generate_grub_config() {
    local tftpname last_flavor file name version flavor initrd

    tftpname=$1
    if [ ! -d "$tftpname" ]; then
        echo "Directory $tftpname does not exist"
        return 1
    fi

    # Ensure default values for BOOT_METHODS, CMDLINE_LINUX_DEFAULTS, CMDLINE_NFS 
    # and CMDLINE_NBD. Distros *should* ship an /etc/ltsp/update-kernels.conf with
    # appropriate values for their distro.
    BOOT_METHODS=${BOOT_METHODS:-"NFS NBD AOE"}
    CMDLINE_LINUX_DEFAULTS=${CMDLINE_LINUX_DEFAULTS:-"ro init=/sbin/init-ltsp"}
    CMDLINE_NFS=${CMDLINE_NFS:-"root=/dev/nfs ip=dhcp"}
    CMDLINE_NBD=${CMDLINE_NBD:-"root=/dev/nbd0"}
    CMDLINE_AOE=${CMDLINE_AOE:-"root=/dev/etherd/e0.0"}

    # Set a default BOOTPROMPT_OPTS using the first defined in BOOT_METHODS
    boot_method_default=$(echo $BOOT_METHODS | awk '{print $1}')
    cmdline_method_default=$(eval echo '$CMDLINE_'$boot_method_default)
    BOOTPROMPT_OPTS="$CMDLINE_LINUX_DEFAULTS $cmdline_method_default"

    # Those defaults should work on debian-based distros, but shouldn't hurt
    # elsewhere because they wouldn't match actual files and they'd be ignored.
    KERNEL_NAMES=${KERNEL_NAMES:-'s/\(vmlinu[xz]-\)\([^-]*-[^-]*-\)\(.*\)/& \1 \2 \3/p'}
    INITRD_NAME=${INITRD_NAME:-'s/vmlinu[xz]/initrd.img/p'}
    GRUBCFG="/$tftpdir/$TFTP_BOOT_DIR/$name/grub"

    # Remove all autogenerated menus.
    rm -f $GRUBCFG/ltsp* $GRUBCFG/grub.cfg $GRUBCFG/memtest.cfg

    cat > $GRUBCFG/ltsp.cfg <<EOF
# This file is regenerated when update-kernels runs.  Do not edit
# directly, edit the client's /etc/ltsp/update-kernels.conf instead.

set timeout=${TIMEOUT:-0}
set default=0

if [ "\${grub_platform}" == efi ]; then
    insmod efi_gop
    insmod efi_uga
fi

regexp --set=1:m1 --set=2:m2 --set=3:m3 --set=4:m4 --set=5:m5 --set=6:m6 '^([0-9a-f]{1,2})\:([0-9a-f]{1,2})\:([0-9a-f]{1,2})\:([0-9a-f]{1,2})\:([0-9a-f]{1,2})\:([0-9a-f]{1,2})' "\$net_default_mac"
bootif=\${m1}-\${m2}-\${m3}-\${m4}-\${m5}-\${m6}

EOF

    grub_include_files=""
    for method in $BOOT_METHODS ; do
        grub_include_files="$grub_include_files ltsp-$method"
        # Get the preferred default kernel, preferred 32-bit kernel, or any 
        # kernel.
        version=$(LIST_KERNELS="$LIST_KERNELS_DEFAULT $LIST_KERNELS_32 ALL" kernel_versions | head -n 1)
    	cat > $GRUBCFG/ltsp-$method.cfg <<EOF
# This file is regenerated when update-kernels runs.
# Do not edit, see /etc/ltsp/update-kernels.conf instead.

menuentry "LTSP, using $method" --class os {
     echo "Loading Linux..."
     linux /$TFTP_BOOT_DIR/$name/vmlinuz${version:+-"$version"} ro $CMDLINE_LINUX_DEFAULT $(eval echo '$CMDLINE_'$method) BOOTIF=\${bootif}
     echo "Loading initial ramdisk..."
     initrd /$TFTP_BOOT_DIR/$name/initrd.img${version:+-"$version"}
}

EOF

    done


    # Add entries for each kernel and boot method,
    # Which needs a corresponding CMDLINE_ for each defined method.
    # i.e. CMDLINE_NFS or CMDLINE_NBD
    # Also requires that CMDLINE_LINUX_DEFAULT is set to a sane value.
    kversions=$(kernel_versions)
    if [ -n "$kversions" ]; then
        for method in $BOOT_METHODS ; do
            grub_include_files="$grub_include_files ltsp-versions-$method"
            cat > $GRUBCFG/ltsp-versions-$method.cfg <<EOF
# This file is regenerated when update-kernels runs.
# Do not edit, see /etc/ltsp/update-kernels.conf instead.

submenu "Other LTSP boot options using $method" {

EOF
            for version in $kversions ; do
                cat >> $GRUBCFG/ltsp-versions-$method.cfg <<EOF
    menuentry "LTSP, using $method, with Linux $version" --class os {
         echo "Loading Linux..."
         linux /$TFTP_BOOT_DIR/$name/vmlinuz-$version ro $CMDLINE_LINUX_DEFAULT $(eval echo '$CMDLINE_'$method) BOOTIF=\${bootif}
         echo "Loading initial ramdisk..."
         initrd /$TFTP_BOOT_DIR/$name/initrd.img-$version
    }

EOF
            done
            cat >> $GRUBCFG/ltsp-versions-$method.cfg <<EOF
    menuentry "Return to main menu" {
        menuinteractive=yes
        configfile "/$TFTP_BOOT_DIR/$name/grub/ltsp.cfg"
    }

}

EOF
        done
    fi

    if [ -f "/$tftpdir/$TFTP_BOOT_DIR/$name/memtest86+.bin" ]; then
        grub_include_files="$grub_include_files memtest"
        cat > $GRUBCFG/memtest.cfg <<EOF
# This file is regenerated when update-kernels runs.
# Do not edit, see /etc/ltsp/update-kernels.conf instead.

if [ "\${grub_platform}" != efi ]; then
    menuentry "Memory test" {
        linux16 "/$TFTP_BOOT_DIR/$name/memtest86+.bin"
    }
fi

EOF
    fi


    for file in $grub_include_files ; do
        if [ -f "$GRUBCFG/$file.cfg" ]; then
            cat "$GRUBCFG/$file.cfg" >> $GRUBCFG/ltsp.cfg
        fi
    done
    ln -s ltsp.cfg $GRUBCFG/grub.cfg
}

# Create symlinks for each kernel flavor in the tftp dir.
# It requires that the distro-specific $KERNEL_NAMES and $INITRD_NAME variables
# are declared in $CHROOT/etc/ltsp/update-kernels.conf.
link_kernel_flavors() {
    local tftpname last_flavor file name version flavor initrd

    tftpname=$1
    if [ ! -d "$tftpname" ]; then
        echo "Directory $tftpname does not exist"
        return 1
    fi

    # Those defaults should work on debian-based distros, but shouldn't hurt
    # elsewhere because they wouldn't match actual files and they'd be ignored.
    KERNEL_NAMES=${KERNEL_NAMES:-'s/\(vmlinu[xz]-\)\([^-]*-[^-]*-\)\(.*\)/& \1 \2 \3/p'}
    INITRD_NAME=${INITRD_NAME:-'s/vmlinu[xz]/initrd.img/p'}

    last_flavor=
    find "$tftpname" -mindepth 1 -maxdepth 1 -type f -printf "%f\n" \
    | sed -n "$KERNEL_NAMES" | sort -k 4,4V -k 3,3rV \
    | while read file name version flavor; do
        if [ "$flavor" != "$last_flavor" ]; then
            initrd=$(echo "$file" | sed -n "$INITRD_NAME")
            if [ ! -e "$tftpname/$initrd" ]; then
                echo "Ignoring $file because the matching $initrd doesn't exist" >&2
                continue
            fi
            ln -sf "$file" "$tftpname/$name$flavor"
            ln -sf "$initrd" "$tftpname/$(echo "$name$flavor" | sed -n "$INITRD_NAME")"
            last_flavor=$flavor
        fi
    done
}

# distro specific functions

# For all kernels in TFTP, find the kernel $version from vmlinuz-* filename.
# If the corresponding /opt/ltsp/$name/lib/modules/$version is missing,
# then delete kernel and images for this version from tftpboot directory.
# Distros that don't match vmlinuz-* should override this function.
cleanup_kernels() {
    local name tftpboot chroot
    name=$1
    tftpboot=$2
    chroot=$3

    # Loop through every vmlinuz-* file
    for kernelpath in $(find "$tftpboot/$name/" -type f -name 'vmlinuz-*' -o -name 'vmlinux-*'); do
        kernel=${kernelpath##*/}
        case $kernel in
            vmlinuz-*) version=${kernel#vmlinuz-} ;;
            vmlinux-*) version=${kernel#vmlinux-} ;;
        esac
        if [ ! -d "$chroot/lib/modules/$version" ]; then
            echo "Removing $kernelpath"
            # Common
            rm -f "$tftpboot/$name/$kernel"
            rm -f "$tftpboot/$name/config-$version"
            rm -f "$tftpboot/$name/System.map-$version"
            rm -rf "$tftpboot/$name/dtbs-$version/"
            # Fedora
            rm -f "$tftpboot/$name/initrd-$version.img"
            rm -f "$tftpboot/$name/initramfs-$version.img"
            rm -f "$tftpboot/$name/elf-$version.img"
            rm -f "$tftpboot/$name/wraplinux-nbi-$version.img"
            rm -f "$tftpboot/$name/aout-$version.img"
            rm -f "$tftpboot/$name/symvers-$version.gz"
            # Debian
            rm -f "$tftpboot/$name/initrd.img-$version"
            rm -f "$tftpboot/$name/nbi.img-$version"
            # Ubuntu
            rm -f "$tftpboot/$name/abi-$version"
            rm -f "$tftpboot/$name/vmcoreinfo-$version"
        fi
    done
}

# Set an optional MODULES_BASE, so help2man can be called from build env
MODULES_BASE=${MODULES_BASE:-/usr/share/ltsp}

# This also sources vendor functions and .conf file settings
. ${MODULES_BASE}/ltsp-server-functions

if ! args=$(getopt -n "$0" -o b:h \
    -l "base:,help,version" -- "$@")
then
    exit 1
fi
eval "set -- $args"
while true ; do
    case "$1" in
        -b|--base) shift; BASE=$1 ;;
        -h|--help) usage; exit 0 ;;
        --version) ltsp_version; exit 0 ;;
        --) shift ; break ;;
        *) die "$0: Internal error!" ;;
    esac
    shift
done
require_root

BASE=${BASE:-"/opt/ltsp"}
# Remove trailing /, if present
BASE=${BASE%/}

# Chroots can be specified in the command line. If not, update all of them.
if [ $# -eq 0 ]; then
    set -- $(
        {
            find -L "$BASE/" -mindepth 1 -maxdepth 1 -type d ! -name images \
                ! -name lost+found -printf "%f\n"
            if [ -d "$BASE/images/" ]; then
                find -L "$BASE/images/" -mindepth 1 -maxdepth 1 -type f \
                    -name '*.img' -printf "%f\n" | sed 's/.img$//'
            fi
        } | sort -u
    )
fi
test $# -gt 0 || die "No chroots found in $BASE"

for tftpdir in $TFTP_DIRS; do
    if [ ! -d "$tftpdir" ]; then
        # skip directory
        continue
    fi
    for name in "$@"; do
        update_kernels "$name" "$tftpdir"
    done
    # Update selinux file contexts if necessary
    if [ -f /selinux/enforce ] && [ -x /sbin/restorecon ]; then
        restorecon -R "$tftpdir" > /dev/null
    fi
done
